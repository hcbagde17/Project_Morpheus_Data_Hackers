# Security Improvement Plan — Encryption Details

> Companion to `Security_Improvement_Plan.md`. Specifies the exact encryption algorithm, parameters, and rationale for each issue that requires cryptographic controls.

---

## Issue #2 — Password Hashing

| Field | Value |
|---|---|
| **Data** | `users.password_hash` in Supabase |
| **Algorithm** | **Argon2id** |
| **Parameters** | Memory: 64 MB · Iterations: 3 · Parallelism: 2 · Output: 32 bytes |
| **Library** | `argon2` (Node.js) or `argon2-browser` (WASM, renderer-side) |
| **Why** | Memory-hard; GPU/ASIC brute-force resistant. Replaces unsalted SHA-256. Each password gets a unique random 16-byte salt generated by `crypto.randomBytes(16)`. |

---

## Issue #3 — Session Token Signing

| Field | Value |
|---|---|
| **Data** | Auth JWT (replacing current `btoa` base64 token) |
| **Algorithm** | **RS256** (RSA-PKCS#1-v1.5-SHA256) or **ES256** (ECDSA P-256) |
| **Key Size** | RS256: 2048-bit RSA · ES256: 256-bit EC (P-256 curve) — ES256 preferred for smaller tokens |
| **Library** | `jose` (Node.js/browser compatible) |
| **Why** | Cryptographically signed: tampering with the `role` field invalidates the signature. Public key can be shared for client-side verify; private key stays server-side only. |

**Key generation (one-time, at deploy):**
```bash
# ES256 (preferred)
openssl ecparam -name prime256v1 -genkey -noout -out ec-private.pem
openssl ec -in ec-private.pem -pubout -out ec-public.pem
```

---

## Issue #4 — Face Embedding (localStorage fallback)

| Field | Value |
|---|---|
| **Data** | Face embedding float vector (`pw_test_face_embedding`) |
| **Algorithm** | **AES-256-GCM** |
| **Parameters** | 256-bit key · 96-bit random IV per operation · 128-bit authentication tag |
| **Key derivation** | `HKDF-SHA256` from `(sessionId + serverSecret)` — key never stored locally |
| **Library** | `crypto.subtle.encrypt` (Web Crypto API, built-in) |
| **Why** | GCM provides both confidentiality and tamper detection. If the stored ciphertext is edited, decryption will fail (auth tag mismatch), preventing embedding replacement attacks. |

> **Ideal fix:** Remove localStorage path entirely (see Improvement Plan). Use this encryption *only* if the path must temporarily remain.

---

## Issue #1 — Supabase Credentials at Build Time

| Field | Value |
|---|---|
| **Data** | `SUPABASE_URL`, `SUPABASE_ANON_KEY` |
| **Approach** | **Envelope encryption via SOPS / Age** |
| **Algorithm** | Age: **ChaCha20-Poly1305** (256-bit key) |
| **Storage** | `.env.enc` committed to repo; plaintext `.env` only on CI runner / developer machine |
| **Why** | ChaCha20-Poly1305 is AEAD (authenticated encryption); avoids padding oracle attacks. Age is simple, modern, and has no legacy baggage. |

---

## Issue #14 — Evidence Video Clips (in transit + at rest)

| Field | Value |
|---|---|
| **In transit** | **TLS 1.3** (enforced by Supabase; verify `min-version: TLS1.3` in project settings) |
| **At rest (Supabase Storage)** | **AES-256** server-side encryption (enabled by default in Supabase; confirm in Dashboard → Storage settings) |
| **Key exchange** | **ECDHE** (Ephemeral Diffie-Hellman) over P-256 or X25519 — provides Perfect Forward Secrecy |
| **Why** | Even if a session key is later compromised, past traffic cannot be decrypted (PFS guarantee). |

---

## Algorithm Quick Reference

```
Passwords     →  Argon2id   (memory=64 MB, iter=3, salt=16 B random)
JWT signing   →  ES256      (ECDSA P-256) or RS256 (RSA-2048)
Symmetric     →  AES-256-GCM (256-bit key, 96-bit IV, 128-bit tag)
Secrets mgmt  →  Age / SOPS  (ChaCha20-Poly1305)
In-transit    →  TLS 1.3    (ECDHE key exchange, PFS)
Key derivation→  HKDF-SHA256
```

> **Core rule:** Never use SHA-256 alone for passwords. Always pair symmetric encryption with GCM mode for tamper detection. Store all keys outside the app bundle.
